---
title: js继承
date: 2021-03-20 09:15:03
tags:
  - [前端]
---

<br>
<!--more-->

### 一、原型对象、实例、原型链

```js
var M = function () {
  this.name = "123";
}; //ƒ (){this.name='123'}
var a1 = new M(); //M {name: "123"}
console.log(a1.name); //123
```

**构造函数**：现在 M 就是构造函数。任何一个函数被 new 使用后，就是构造函数，没被 new 使用过的就是普通函数。（new 后面的函数就是构造函数）

**实例对象**：现在 a1 就叫实例 ，js 中，被 new 出来的对象都叫做实例对象，也叫实例，（所以实例都是对象，对象不一定是实例）

**原型对象**：现在 M.protoype 就是原型对象，任何一个函数都有 prototype 属性，这个属性是声明函数时 js 自动加的，prototype 初始时是一个空对象，这个对象就叫原型对象

1. 构造函数：(例子中 M) new 出来的东西就叫实例，
   prototype 属性就叫原型对象
2. 原型对象 (M.prototype) 中的 constructor 等于构造函数，
   `M.prototype.constructor===M // true`

3. 实例 （a1）的 `__proto__` 属性就是 构造函数(M)的 prototype
   `a1.__proto__ === M.prototype //ture`

要查一个实例对象中的值时，首先通过本身的**proto**属性找到他的原型对象，然后再通过他的原型对象的**proto**找到他的原型对象，一直找，递归访问**proto**最终到头，并且值是 null，这个过程从头到结束就叫原型链。找到了就返回值，找不到就返回 undefind

还有一个比较重要的，不止构造函数有\_\_proto 属性，普通函数也有，因为普通函数是 Function 的实例。

```js
var M3 = function () {
  this.n = 1;
};

M3.__proto__.constructor === Function; //true
```

### 创建对象的 3 种方法：

```js
//自变量创建，通过原型链指向Object
var o1 = { name: 123 };
var o2 = new Object({ name: 123 });
//构造函数创建

var M = function (name) {
  this.name = name;
};
var o2 = new M(123);
//注意，如果 M 不需要入参可以写成
var M = function () {
  this.name = 123;
};
var o2 = new M();
//object.create()给参数中这个对象，作为一个新对象的原型对象，赋值给o4
var p = { name: 123 };
var o4 = object.create(p);
```
